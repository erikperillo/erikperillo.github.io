\hypertarget{group__sw__timer}{}\section{Software Timer}
\label{group__sw__timer}\index{Software Timer@{Software Timer}}


This module is used to interface with Abstract Timer H\+AL to generate periodical timeouts required through different modules of the A\+OA protocol. This block will be based on 1ms ticks for all the timeout calculations. The H\+AL Interface block used to communicate with this must have the same 1ms timeout configured. This module can generate different software timer channels based on the same 1ms.  


\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef enum \hyperlink{group__sw__timer_ga44b572e8abe4da32037ad911b133f0be}{Sw\+Timer\+Channel\+Status} \hyperlink{group__sw__timer_ga11c8ba265a273d5d3dda5e269163d3e7}{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t}
\item 
typedef int32\+\_\+t \hyperlink{group__sw__timer_ga85b49889ff28c6bc6a5368a08b0f9650}{time\+\_\+counter\+\_\+t}
\item 
typedef uint32\+\_\+t \hyperlink{group__sw__timer_gaf131d055058588461e646ccea72592bc}{time\+\_\+free\+\_\+counter\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{group__sw__timer_ga44b572e8abe4da32037ad911b133f0be}{Sw\+Timer\+Channel\+Status} \{ \hyperlink{group__sw__timer_gga44b572e8abe4da32037ad911b133f0beaccc7b14e60e47ddac04fd489a4d17cf0}{k\+Sw\+Timer\+Channel\+Expired} = 0x00, 
\hyperlink{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea52d9aacf178b2dcb1bb96a73b5dac3ef}{k\+Sw\+Timer\+Channel\+Still\+Counting} = 0x01, 
\hyperlink{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea4bb8ee91a14fd415eb2a8eae57c610b5}{k\+Sw\+Timer\+Channel\+Is\+Disable} = 0x02, 
\hyperlink{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea38fb994fa8e94a6d4481aee3aee7943e}{k\+Sw\+Timer\+Channel\+Not\+Available} = 0x\+FF
 \}
\item 
enum \hyperlink{group__sw__timer_gab8c4026a7bceba5518af412d2d289c9c}{\+\_\+sw\+\_\+timer\+\_\+errors} \{ \hyperlink{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9caab7c18ff1b7358fc892f275d3a0702c1}{k\+Sw\+Timer\+Status\+Success}, 
\hyperlink{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9ca89b47823684a90940d1eccf3ee9407f9}{k\+Sw\+Timer\+Status\+Fail}, 
\hyperlink{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9cae3ac3f7f169fff145d07a271193af420}{k\+Sw\+Timer\+Status\+Invalid\+Channel}
 \}
\item 
enum \hyperlink{group__sw__timer_ga8eb74c42765e0114fb15920babe0db28}{sw\+\_\+timer\+\_\+timeouts} \{ {\bfseries k\+Sw\+Timer\+Max\+Timeout} = 2147483647
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{group__sw__timer_ga3c3614b044470b0fbaf07fe74b061406}{sw\+\_\+timer\+\_\+init\+\_\+service} (void)
\begin{DoxyCompactList}\small\item\em Initializes the software timer module. Prepares variables and H\+AL layer to provide timer services. Starts the free running counter which will be available to get its value any time while the service is running; it is useful whenever a module wants to keep track of time, but do not wants to reserve a channel. \end{DoxyCompactList}\item 
void \hyperlink{group__sw__timer_gaf9f4848ee97f18dbeceb31aded25ec5c}{sw\+\_\+timer\+\_\+shutdown\+\_\+service} (void)
\begin{DoxyCompactList}\small\item\em Deinitializes the software timer module. Shutdown H\+AL layer, so no timer service can be provided after the execution of this function. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{group__sw__timer_gaeb2e62af95eb77e6b9427d78c3e02bdd}{sw\+\_\+timer\+\_\+reserve\+\_\+channel} (void)
\begin{DoxyCompactList}\small\item\em Reserves a free timer channel to be used by any module and returns its identifier. \end{DoxyCompactList}\item 
\hyperlink{group__sw__timer_ga11c8ba265a273d5d3dda5e269163d3e7}{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t} \hyperlink{group__sw__timer_gad704fb2eb92414b57e13df021591593d}{sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status} (uint8\+\_\+t timer\+Channel)
\begin{DoxyCompactList}\small\item\em Returns the actual status of the given timer channel. The timer has to be previously started to return a valid status. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{group__sw__timer_ga755aef7ee6f71dac4b4978a076b0c447}{sw\+\_\+timer\+\_\+start\+\_\+channel} (uint8\+\_\+t timer\+Channel, \hyperlink{group__sw__timer_ga85b49889ff28c6bc6a5368a08b0f9650}{time\+\_\+counter\+\_\+t} timeout)
\begin{DoxyCompactList}\small\item\em Starts the count down of the given timer channel. The timer channel has to be previously reserved. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{group__sw__timer_ga7b71ad88ee7b0ef5d46b822a7b4ff2ea}{sw\+\_\+timer\+\_\+release\+\_\+channel} (uint8\+\_\+t timer\+Channel)
\begin{DoxyCompactList}\small\item\em Releases the given timer channel, so it can be used by someone else. \end{DoxyCompactList}\item 
\hyperlink{group__sw__timer_gaf131d055058588461e646ccea72592bc}{time\+\_\+free\+\_\+counter\+\_\+t} \hyperlink{group__sw__timer_ga1831e6f6e86215c63e02b5c3ab51bf6c}{sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter} (void)
\begin{DoxyCompactList}\small\item\em Gets the current value of the free running counter. Any module can keep track of the time by reading this counter and calculates time difference. No reservation of timer channel is needed. Consider for calculations that when the counter overflows it will start from 0 again. \end{DoxyCompactList}\item 
void \hyperlink{group__sw__timer_gaabb732c0d372fe28a21b0b3d2c32e326}{sw\+\_\+timer\+\_\+update\+\_\+counters} (void)
\begin{DoxyCompactList}\small\item\em This function is called every 1ms by the interruption and update count down values of all timer channels. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This module is used to interface with Abstract Timer H\+AL to generate periodical timeouts required through different modules of the A\+OA protocol. This block will be based on 1ms ticks for all the timeout calculations. The H\+AL Interface block used to communicate with this must have the same 1ms timeout configured. This module can generate different software timer channels based on the same 1ms. 



\subsection{Typedef Documentation}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t@{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t}}
\index{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t@{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t}{sw_timer_channel_status_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf Sw\+Timer\+Channel\+Status} {\bf sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t}}\hypertarget{group__sw__timer_ga11c8ba265a273d5d3dda5e269163d3e7}{}\label{group__sw__timer_ga11c8ba265a273d5d3dda5e269163d3e7}
Definition of the possible status of a software channel timer. \index{Software Timer@{Software Timer}!time\+\_\+counter\+\_\+t@{time\+\_\+counter\+\_\+t}}
\index{time\+\_\+counter\+\_\+t@{time\+\_\+counter\+\_\+t}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{time\+\_\+counter\+\_\+t}{time_counter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef int32\+\_\+t {\bf time\+\_\+counter\+\_\+t}}\hypertarget{group__sw__timer_ga85b49889ff28c6bc6a5368a08b0f9650}{}\label{group__sw__timer_ga85b49889ff28c6bc6a5368a08b0f9650}
Data type of the counter of each timer channel. If it is an int8\+\_\+t the counter will count up to 127ms, int16\+\_\+t up to 32767ms and int32\+\_\+t up to 2147483647ms. \index{Software Timer@{Software Timer}!time\+\_\+free\+\_\+counter\+\_\+t@{time\+\_\+free\+\_\+counter\+\_\+t}}
\index{time\+\_\+free\+\_\+counter\+\_\+t@{time\+\_\+free\+\_\+counter\+\_\+t}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{time\+\_\+free\+\_\+counter\+\_\+t}{time_free_counter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint32\+\_\+t {\bf time\+\_\+free\+\_\+counter\+\_\+t}}\hypertarget{group__sw__timer_gaf131d055058588461e646ccea72592bc}{}\label{group__sw__timer_gaf131d055058588461e646ccea72592bc}
Data type of the free running counter. This data type should be unsigned and will count up to 255ms if it is uint8\+\_\+t, 65535ms for uint16\+\_\+t and 4294967295ms for uint32\+\_\+t. 

\subsection{Enumeration Type Documentation}
\index{Software Timer@{Software Timer}!\+\_\+sw\+\_\+timer\+\_\+errors@{\+\_\+sw\+\_\+timer\+\_\+errors}}
\index{\+\_\+sw\+\_\+timer\+\_\+errors@{\+\_\+sw\+\_\+timer\+\_\+errors}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{\+\_\+sw\+\_\+timer\+\_\+errors}{_sw_timer_errors}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf \+\_\+sw\+\_\+timer\+\_\+errors}}\hypertarget{group__sw__timer_gab8c4026a7bceba5518af412d2d289c9c}{}\label{group__sw__timer_gab8c4026a7bceba5518af412d2d289c9c}
List of status and errors. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Sw\+Timer\+Status\+Success@{k\+Sw\+Timer\+Status\+Success}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Status\+Success@{k\+Sw\+Timer\+Status\+Success}}\item[{\em 
k\+Sw\+Timer\+Status\+Success\hypertarget{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9caab7c18ff1b7358fc892f275d3a0702c1}{}\label{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9caab7c18ff1b7358fc892f275d3a0702c1}
}]The execution was successful. \index{k\+Sw\+Timer\+Status\+Fail@{k\+Sw\+Timer\+Status\+Fail}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Status\+Fail@{k\+Sw\+Timer\+Status\+Fail}}\item[{\em 
k\+Sw\+Timer\+Status\+Fail\hypertarget{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9ca89b47823684a90940d1eccf3ee9407f9}{}\label{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9ca89b47823684a90940d1eccf3ee9407f9}
}]The execution failed. \index{k\+Sw\+Timer\+Status\+Invalid\+Channel@{k\+Sw\+Timer\+Status\+Invalid\+Channel}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Status\+Invalid\+Channel@{k\+Sw\+Timer\+Status\+Invalid\+Channel}}\item[{\em 
k\+Sw\+Timer\+Status\+Invalid\+Channel\hypertarget{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9cae3ac3f7f169fff145d07a271193af420}{}\label{group__sw__timer_ggab8c4026a7bceba5518af412d2d289c9cae3ac3f7f169fff145d07a271193af420}
}]The given channel is not valid. Valid channels are 0 to (S\+W\+\_\+\+T\+I\+M\+E\+R\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+C\+H\+A\+N\+N\+E\+LS -\/ 1). \end{description}
\end{Desc}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+timeouts@{sw\+\_\+timer\+\_\+timeouts}}
\index{sw\+\_\+timer\+\_\+timeouts@{sw\+\_\+timer\+\_\+timeouts}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+timeouts}{sw_timer_timeouts}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf sw\+\_\+timer\+\_\+timeouts}}\hypertarget{group__sw__timer_ga8eb74c42765e0114fb15920babe0db28}{}\label{group__sw__timer_ga8eb74c42765e0114fb15920babe0db28}
Max timeout value according to size of the time counter \index{Software Timer@{Software Timer}!Sw\+Timer\+Channel\+Status@{Sw\+Timer\+Channel\+Status}}
\index{Sw\+Timer\+Channel\+Status@{Sw\+Timer\+Channel\+Status}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{Sw\+Timer\+Channel\+Status}{SwTimerChannelStatus}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Sw\+Timer\+Channel\+Status}}\hypertarget{group__sw__timer_ga44b572e8abe4da32037ad911b133f0be}{}\label{group__sw__timer_ga44b572e8abe4da32037ad911b133f0be}
Definition of the possible status of a software channel timer. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Sw\+Timer\+Channel\+Expired@{k\+Sw\+Timer\+Channel\+Expired}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Channel\+Expired@{k\+Sw\+Timer\+Channel\+Expired}}\item[{\em 
k\+Sw\+Timer\+Channel\+Expired\hypertarget{group__sw__timer_gga44b572e8abe4da32037ad911b133f0beaccc7b14e60e47ddac04fd489a4d17cf0}{}\label{group__sw__timer_gga44b572e8abe4da32037ad911b133f0beaccc7b14e60e47ddac04fd489a4d17cf0}
}]Indicates the timer channel has counted the given ms \index{k\+Sw\+Timer\+Channel\+Still\+Counting@{k\+Sw\+Timer\+Channel\+Still\+Counting}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Channel\+Still\+Counting@{k\+Sw\+Timer\+Channel\+Still\+Counting}}\item[{\em 
k\+Sw\+Timer\+Channel\+Still\+Counting\hypertarget{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea52d9aacf178b2dcb1bb96a73b5dac3ef}{}\label{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea52d9aacf178b2dcb1bb96a73b5dac3ef}
}]Indicates the timeout of the channel has not expired and the timer is still counting. \index{k\+Sw\+Timer\+Channel\+Is\+Disable@{k\+Sw\+Timer\+Channel\+Is\+Disable}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Channel\+Is\+Disable@{k\+Sw\+Timer\+Channel\+Is\+Disable}}\item[{\em 
k\+Sw\+Timer\+Channel\+Is\+Disable\hypertarget{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea4bb8ee91a14fd415eb2a8eae57c610b5}{}\label{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea4bb8ee91a14fd415eb2a8eae57c610b5}
}]Indicates the timer channel is not reserved. \index{k\+Sw\+Timer\+Channel\+Not\+Available@{k\+Sw\+Timer\+Channel\+Not\+Available}!Software Timer@{Software Timer}}\index{Software Timer@{Software Timer}!k\+Sw\+Timer\+Channel\+Not\+Available@{k\+Sw\+Timer\+Channel\+Not\+Available}}\item[{\em 
k\+Sw\+Timer\+Channel\+Not\+Available\hypertarget{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea38fb994fa8e94a6d4481aee3aee7943e}{}\label{group__sw__timer_gga44b572e8abe4da32037ad911b133f0bea38fb994fa8e94a6d4481aee3aee7943e}
}]Indicates there are not available channels to reserve or the requested channel is not available. \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status@{sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status}}
\index{sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status@{sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status(uint8\+\_\+t timer\+Channel)}{sw_timer_get_channel_status(uint8_t timerChannel)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t} sw\+\_\+timer\+\_\+get\+\_\+channel\+\_\+status (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{timer\+Channel}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_gad704fb2eb92414b57e13df021591593d}{}\label{group__sw__timer_gad704fb2eb92414b57e13df021591593d}


Returns the actual status of the given timer channel. The timer has to be previously started to return a valid status. 


\begin{DoxyParams}{Parameters}
{\em timer\+Channel} & \mbox{[}in\mbox{]} Indicates the timer channel which status is going to be returned.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sw\+\_\+timer\+\_\+channel\+\_\+status\+\_\+t Current status of the given timer channel. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em k\+Sw\+Timer\+Channel\+Expired} & Indicates the timer channel has counted the given ms. \\
\hline
{\em k\+Sw\+Timer\+Channel\+Still\+Counting} & Indicates the timeout of the channel has not expired and the timer is still counting. \\
\hline
{\em k\+Sw\+Timer\+Channel\+Is\+Disable} & Indicates the timer channel is not reserved. \\
\hline
{\em k\+Sw\+Timer\+Channel\+Not\+Available} & Indicates the timer channel is invalid. \\
\hline
\end{DoxyRetVals}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter@{sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter}}
\index{sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter@{sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter(void)}{sw_timer_get_free_counter(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf time\+\_\+free\+\_\+counter\+\_\+t} sw\+\_\+timer\+\_\+get\+\_\+free\+\_\+counter (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_ga1831e6f6e86215c63e02b5c3ab51bf6c}{}\label{group__sw__timer_ga1831e6f6e86215c63e02b5c3ab51bf6c}


Gets the current value of the free running counter. Any module can keep track of the time by reading this counter and calculates time difference. No reservation of timer channel is needed. Consider for calculations that when the counter overflows it will start from 0 again. 

\begin{DoxyReturn}{Returns}
time\+\_\+free\+\_\+counter\+\_\+t Returns current count of the free running counter. 
\end{DoxyReturn}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+init\+\_\+service@{sw\+\_\+timer\+\_\+init\+\_\+service}}
\index{sw\+\_\+timer\+\_\+init\+\_\+service@{sw\+\_\+timer\+\_\+init\+\_\+service}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+init\+\_\+service(void)}{sw_timer_init_service(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t sw\+\_\+timer\+\_\+init\+\_\+service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_ga3c3614b044470b0fbaf07fe74b061406}{}\label{group__sw__timer_ga3c3614b044470b0fbaf07fe74b061406}


Initializes the software timer module. Prepares variables and H\+AL layer to provide timer services. Starts the free running counter which will be available to get its value any time while the service is running; it is useful whenever a module wants to keep track of time, but do not wants to reserve a channel. 

\begin{DoxyReturn}{Returns}
status\+\_\+t Returns software timer status after initialization. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em k\+Sw\+Timer\+Status\+Success} & The initialization was successful and the software timer is ready to provide services. \\
\hline
{\em k\+Sw\+Timer\+Status\+Fail} & The initialization failed. \\
\hline
\end{DoxyRetVals}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+release\+\_\+channel@{sw\+\_\+timer\+\_\+release\+\_\+channel}}
\index{sw\+\_\+timer\+\_\+release\+\_\+channel@{sw\+\_\+timer\+\_\+release\+\_\+channel}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+release\+\_\+channel(uint8\+\_\+t timer\+Channel)}{sw_timer_release_channel(uint8_t timerChannel)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t sw\+\_\+timer\+\_\+release\+\_\+channel (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{timer\+Channel}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_ga7b71ad88ee7b0ef5d46b822a7b4ff2ea}{}\label{group__sw__timer_ga7b71ad88ee7b0ef5d46b822a7b4ff2ea}


Releases the given timer channel, so it can be used by someone else. 


\begin{DoxyParams}{Parameters}
{\em timer\+Channel} & \mbox{[}in\mbox{]} Identifier of the timer channel.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status\+\_\+t Reports failures in the execution of the function. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em k\+Sw\+Timer\+Status\+Success} & A channel was released successfully. \\
\hline
{\em k\+Sw\+Timer\+Status\+Invalid\+Channel} & The timer channel is invalid, it does not exist. \\
\hline
\end{DoxyRetVals}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+reserve\+\_\+channel@{sw\+\_\+timer\+\_\+reserve\+\_\+channel}}
\index{sw\+\_\+timer\+\_\+reserve\+\_\+channel@{sw\+\_\+timer\+\_\+reserve\+\_\+channel}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+reserve\+\_\+channel(void)}{sw_timer_reserve_channel(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t sw\+\_\+timer\+\_\+reserve\+\_\+channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_gaeb2e62af95eb77e6b9427d78c3e02bdd}{}\label{group__sw__timer_gaeb2e62af95eb77e6b9427d78c3e02bdd}


Reserves a free timer channel to be used by any module and returns its identifier. 

\begin{DoxyReturn}{Returns}
uint8\+\_\+t Returns the number of the channel that was reserved. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em Any} & value between 0 and S\+W\+\_\+\+T\+I\+M\+E\+R\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+C\+H\+A\+N\+N\+E\+LS is a valid channel. It indicates the channel was reserved and can be used. \\
\hline
{\em k\+Sw\+Timer\+Channel\+Not\+Available} & If there is not any available channel, because all channels are already reserved. \\
\hline
\end{DoxyRetVals}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+shutdown\+\_\+service@{sw\+\_\+timer\+\_\+shutdown\+\_\+service}}
\index{sw\+\_\+timer\+\_\+shutdown\+\_\+service@{sw\+\_\+timer\+\_\+shutdown\+\_\+service}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+shutdown\+\_\+service(void)}{sw_timer_shutdown_service(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void sw\+\_\+timer\+\_\+shutdown\+\_\+service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_gaf9f4848ee97f18dbeceb31aded25ec5c}{}\label{group__sw__timer_gaf9f4848ee97f18dbeceb31aded25ec5c}


Deinitializes the software timer module. Shutdown H\+AL layer, so no timer service can be provided after the execution of this function. 

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+start\+\_\+channel@{sw\+\_\+timer\+\_\+start\+\_\+channel}}
\index{sw\+\_\+timer\+\_\+start\+\_\+channel@{sw\+\_\+timer\+\_\+start\+\_\+channel}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+start\+\_\+channel(uint8\+\_\+t timer\+Channel, time\+\_\+counter\+\_\+t timeout)}{sw_timer_start_channel(uint8_t timerChannel, time_counter_t timeout)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t sw\+\_\+timer\+\_\+start\+\_\+channel (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{timer\+Channel, }
\item[{{\bf time\+\_\+counter\+\_\+t}}]{timeout}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_ga755aef7ee6f71dac4b4978a076b0c447}{}\label{group__sw__timer_ga755aef7ee6f71dac4b4978a076b0c447}


Starts the count down of the given timer channel. The timer channel has to be previously reserved. 


\begin{DoxyParams}{Parameters}
{\em timer\+Channel} & \mbox{[}in\mbox{]} Indicates the timer channel that is going to be started. \\
\hline
{\em timeout} & \mbox{[}in\mbox{]} Time in ms that the timer channel will count. The timeout should be a multiple of count unit of the timer, otherwise it will be taken the integer part of the division and the exact count will not be achieved\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status\+\_\+t Reports failures in the execution of the function. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em k\+Sw\+Timer\+Status\+Success} & A channel was started successfully. \\
\hline
{\em k\+Sw\+Timer\+Status\+Invalid\+Channel} & The timer channel is invalid, it does not exist. \\
\hline
\end{DoxyRetVals}
\index{Software Timer@{Software Timer}!sw\+\_\+timer\+\_\+update\+\_\+counters@{sw\+\_\+timer\+\_\+update\+\_\+counters}}
\index{sw\+\_\+timer\+\_\+update\+\_\+counters@{sw\+\_\+timer\+\_\+update\+\_\+counters}!Software Timer@{Software Timer}}
\subsubsection[{\texorpdfstring{sw\+\_\+timer\+\_\+update\+\_\+counters(void)}{sw_timer_update_counters(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void sw\+\_\+timer\+\_\+update\+\_\+counters (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__sw__timer_gaabb732c0d372fe28a21b0b3d2c32e326}{}\label{group__sw__timer_gaabb732c0d372fe28a21b0b3d2c32e326}


This function is called every 1ms by the interruption and update count down values of all timer channels. 

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
